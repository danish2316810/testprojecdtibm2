const cds = require("@sap/cds");
const { uuid } = require("@sap/cds/lib/utils/cds-utils");
const { INSERT, SELECT } = cds.ql;



module.exports=onCreateErrorRecord

async function onCreateErrorRecord(req) {
    try{
      const {data}=req.data
      const cdsEntityList=cds.entities("app.dan");
      const errorPayload=await formErrorData(data.interface,data.fields,cdsEntityList);
      let x=errorPayload.cdsEntityFullName
      const interfaceData=cdsEntityList.InterfaceData;
      const isFieldsMatch= validateErrorFields(errorPayload)
      let returnRes=""
      if (isFieldsMatch.bNoError) {       
        let tableName=x.split(".")
            tableName=tableName[tableName.length-1]
            returnRes=await createErrorDataInTable(req,tableName,errorPayload,interfaceData)
      }else(
        req.error(isFieldsMatch.error)
      )
      return returnRes;
  
            
    }catch(error){
      return { error: error.message }; 
    }
}

async function createErrorDataInTable(req,tableName,interfaceData){
 
  try {
    const interfaceDataCreationObjcet=await createInterfaceData(req,tableName,errorPayload,interfaceData)
     errorPayload.payloaddata.interfaceUUID=interfaceDataCreationObjcet.interfaceUUID
      console.log(errorPayload.cdsEntityFullName, errorPayload.payloaddata)
     const newRecord=await INSERT.into(errorPayload.cdsEntityFullName, errorPayload.payloaddata)
    
    return newRecord;
  } catch (err) {
    req.error(500, 'Internal Server Error: ' + err.message);
  }
}

async function createInterfaceData(req,tableName,errorPayload,interfaceData) {
  let crtInterfaceAndObject={}
  const {data}= req.data;
  let enabledForReprocessingValue=false;
  if(data.enabledForReprocessing==="Y"){
    enabledForReprocessingValue===true;
  }
  if(data.payload){
    const interfaceData1={
      "ID":uuid.v4(),
      "sourceSystem":data.sourceSystem,
      "iFlowName":data.iFlowName,
      "error_errorCode":data.errorCode,
      "httpErrorCode":data.httpErrorCode,
      "techTableName":tableName,
      "enabledForReprocessing":enabledForReprocessingValue
    }
  }
  crtInterfaceAndObject=await INSERT.into(interfaceData.name, interfaceData1)
}






function validateErrorFields(errorPayload ) {
  let isFieldMatch={}
  if(errorPayload.cdsEntityFullName){
    const cdsEntityFieldsObject=errorPayload.cdsEntityFieldsObject;
      const keysPayloadData=Object.keys(errorPayload.payloaddata);
      isFieldMatch.bNoError=true;
      keysPayloadData.forEach(item=>{
        if(cdsEntityFieldsObject[item]){
          // do nothing
        }else{
          isFieldMatch.bNoError=false;
          isFieldMatch.error=("field is not present")
        }
      })
      if(isFieldMatch.bNoError){
        isFieldMatch=validateValueOfErrorPayload(errorPayload)
        
      }
      
  }else{
    isFieldMatch.bNoError=false;
    isFieldMatch.error="endpoint enity is not available"
  }
  return isFieldMatch;  
}

function validateValueOfErrorPayload(errorPayload) {
  const isFieldsHasValue={}
  const cdsEntityFieldsObject=errorPayload.cdsEntityFieldsObject;
  const payloadData=errorPayload.payloaddata;
  const cdsEntitykeys=Object.keys(errorPayload.cdsEntityFieldsObject)
  // skip validation for autogenerated or internal code assigned/yet to be assign fields
  const autogenCodeAssinValues=["ID", "interfaceUUID"]
  isFieldsHasValue.bNoError=true;
  cdsEntitykeys.forEach(item=>{
    if(cdsEntityFieldsObject[item]){       //results into UUID, STRING, INTERGER,datetime
      // HERE WE ARE GETTING THE SKIP FIELDS FROM LIST OF CDS ENTITY i.e. contract table
      const isSkipField=autogenCodeAssinValues.find(item1=>{
        if(item1===cdsEntityFieldsObject[item].name){ //each cdsEntityFieldsName are checked
          return true;                                //against ID OR UUID
        }else{                                  //the skipping is later used in the validateValue function
          return false;
        }

        })
        if(cdsEntityFieldsObject[item].hasOwnProperty("key")){
          console.log(cdsEntityFieldsObject[item].hasOwnProperty("key"))
        validateValue(cdsEntityFieldsObject,payloadData,item,isFieldsHasValue,isSkipField)
        }else if(cdsEntityFieldsObject[item].hasOwnProperty("notNull")&& cdsEntityFieldsObject[item]!=="cds.Association"){
        validateValue(cdsEntityFieldsObject,payloadData,item,isFieldsHasValue,isSkipField)
      }
    }
  })
  return isFieldsHasValue;
}
function validateValue(cdsEntityFieldsObject,payloadData,item,isFieldsHasValue,isSkipField) {
  if(isSkipField){
    //dont do anything
  }else if(payloadData.hasOwnProperty(cdsEntityFieldsObject[item].name)){
    const value = payloadData[cdsEntityFieldsObject[item].name];

    if(value===null ||value===undefined ||value.length<1 ){
      isFieldsHasValue.bNoError=false;
      isFieldsHasValue.error=`${cdsEntityFieldsObject[item].name} is a required value`    
    } 
  }else{
    isFieldsHasValue.bNoError=false;
      isFieldsHasValue.error=`${cdsEntityFieldsObject[item].name} is a required value`
   }

  
}
async function formErrorData(endPoint,httpPayloadFiledsdata,cdsEntityList) {
  const payload={}
  if(endPoint==="Contract"){
    payload.cdsEntityFullName=cdsEntityList.ContractErrors.name;
    payload.cdsEntityFieldsObject=cdsEntityList.ContractErrors.elements;
    payload.payloaddata=await formBtpTableErrorPayload(httpPayloadFiledsdata)
  }
  return payload;
}
async function formBtpTableErrorPayload(data) {
  const fieldsDataWithoutKeysAndValue={}
  data.forEach(item=>{
    fieldsDataWithoutKeysAndValue[item.keys]=item.value
  })
return fieldsDataWithoutKeysAndValue;
  
}